TcpForwardPlugin plug-in technical documentation
================================================================================

Prepared by:
    Didier Pieroux (BIRA-IASB)
    December 2017



1. Introduction and content
================================================================================

The TcpForwardPlugin is a plug-in for the Stream Extractor (SE). Its goal is to
forward the VMU packets received by the SE to a TCP server.

This document explains how to build, run and test the plug-in (in standalone
mode for the tests). It ends by implementation notes.


Content
-------
    1. Introduction and content
    2. Dependencies
    3. Build
    4. Plug-in parameters
    5. Connection to the server
    6. TcpForwardPlugin tests in stand-alone mode
        6.1. Preparation
        6.2. Test 1a: connection and reconnection
        6.3. Test 1b: reconnection attempt delay
        6.4. Test 2a: ten times "Hello world!" in a row
        6.5. Test 2b: limited message queue
        6.6. Test 3: sending actual VMU packets to Hadock
    7. Implementation notes
        7.1 Concurrent access: the message queue and the sending thread
        7.2 Concurrent access: Static variables and procedures



2. Dependencies
================================================================================

This version of the plug-in has been developed for
    - the SE version v2.2.3
    - the DassAPI v3.8
    - the g++ (GNU C++) compiling system v4.1.2 (20070115)

Note: the plug-in has also been built successfully in standalone mode with g++
4.3.4 and g++ 4.8.5.



3. Build
================================================================================

There are two available builds the plug-in: as an actual plug-in of the SE or as
a standalone version. The former requires DassAPI to be installed and the
DASSROOT environment variable to be set to the root of that library.

To build (or clean) the standalone version, add 'STANDALONE=1' after make.

Therefore:
    make: build the actual plug-in. Require DASSROOT to be set.

    make clean: remove the items generated by the actual plug-in build. Require
                DASSROOT to be set.

    make STANDALONE=1: build the standalone version of the plug-in, including
                       the test driver.

    make STANDALONE=1 clean: clean the items generated by the standalone version
                             of the plug-in.

Note: it is necessary to clean when switching between the actual plug-in and
standalone versions of the plug-in.



4. Plug-in parameters
================================================================================

The plug-in takes three parameters separated by a comma:
    - the address:port of the TCP server to which to connect;
    - the delay, in seconds, between two successive connection attempts to the
      server;
    - the size, in number of enqueued messages, of the message queue.

The format is "host:port, delay, queueSize"; e.g. -pp "10.0.0.14:2000, 5, 0"
when run from the SE. The double quotes are necessary to avoid that the spaces
after the commas be interpreted as separator characters.

Notes:
    a. In case of a bounded queue, the oldest packet is discarded if a new VMU
       packet is received if the queue is full.
    b. Setting the queue size to zero leads to an unbounded queue. This might
       lead to memory exhaustion if data packets are received faster than what
       they can be sent to the TCP server.



5. Connection to the server
================================================================================

The plug-in attempts to connect to the TCP server at start.

If the connection fails to establish, or if later on it closes unexpectedly, the
plug-in attempts to reconnect periodically, the delay between two attempts being
given by the second plug-in parameter.

Note that in the absence of an established connection to the TCP server, the
received VMU packets are discarded to avoid that they accumulate in memory.




================================================================================
6. TcpForwardPlugin tests in stand-alone mode
================================================================================

This section describes the verification tests of the plug-in in standalone mode,
i.e. without interaction with the SE framework and the Dass API library.

The netcat utility, which is available on common Linux Distribution, is used as
TCP server.

Notations:
    - ">" represents the shell prompt.
    - "=>" is used to indicate the response of the system.



6.1. Preparation
--------------------------------------------------------------------------------

Objective
    To build and test a standalone version of the plug-in.


Prerequisites
    Availability of the gnu C++ (g++) compiler
    Availability of the 'make' tool


Execution
    Open a shell, cd into the plug-in folder and build the standalone version:
        > cd <...>/TcpForwardPlugin
        > make STANDALONE=1 clean
        > make STANDALONE=1

    To test the build phase, type './TestDriver'.
        > ./TestDriver

    => The application displays a help message.


Problems
    a) compilation or link error

        The code was successfully built with g++ 4.1.2 on a virtual cdmcs-d
        server, with g++ 4.3.4 on kronos and with g++ 4.8.5 on crunch6, the two
        last being development servers of BIRA-IASB.

        A compilation error might be caused by a too recent C++ compiler. In
        particular, support to C++11 should be deactivated.


    b) shared libraries not found error

        TestDriver reports that it cannot find the plug-in library:

        > ./TestDriver
        => ./TestDriver: error while loading shared libraries:
           TcpForwardPlugin-1.0.0.so: cannot open shared object file:
           No such file or directory

        Solution: add the current path the LD_LIBRARY_PATH:

        > LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH



6.2. Test 1a: connection and reconnection
--------------------------------------------------------------------------------

Objective
    To test the connection and reconnection functionality of the plug-in.


Prerequisites
    1. The preparation step (ยง 6.1) was successfully
    2. The netcat tool is available
    4. Shell 1 is open in the plug-in folder
    4. Shell 2 is open
    5. The TCP port 2500 is not in used (if it is in use, simply use another
       available port for the test)


Execution

    1) In shell 1, start the test: ./TestDriver 1 "127.0.0.1:2500, 2, 0"

    => The plug-in attempts to connect to the server every 2 seconds

        INFO:  TcpForwardPlugin: Init called
        INFO:  TcpForwardPlugin: parameters: 127.0.0.1:2500, 2, 0
        INFO:  TcpForwardPlugin: server host: 127.0.0.1; port: 2500
        INFO:  TcpForwardPlugin: reconnect delay: 2 s
        INFO:  TcpForwardPlugin: unlimited msg queue size
        INFO:  TcpForwardPlugin: mission mode: 1
        INFO:  TcpForwardPlugin: TCP/IP layer initialisation
        INFO:  TcpForwardPlugin: starting TCP layer thread
        INFO:  TcpForwardPlugin: waiting for connection
        INFO:  TcpForwardPlugin: connecting to 127.0.0.1:2500
        ERROR: TcpForwardPlugin: failure to connect; errno = 111
        INFO:  TcpForwardPlugin: connecting to 127.0.0.1:2500
        ERROR: TcpForwardPlugin: failure to connect; errno = 111
        ...

    2) Start netcat in shell 2: netcat -l -p 2500

    => At the next connection attempt by the plug-in, the connection succeeds:

        ...
        ERROR: TcpForwardPlugin: failure to connect; errno = 111
        INFO:  TcpForwardPlugin: connecting to 127.0.0.1:2500
        INFO:  TcpForwardPlugin: connected to server
        INFO:  TcpForwardPlugin: connected
        ...

    => Once the connection is established, the TestDriver closes the socket.
    => As a result netcat returns and the plug-in tries to reconnect:

        ...
        INFO:  TcpForwardPlugin: connected
        INFO:  TcpForwardPlugin: closing TCP connection
        INFO:  TcpForwardPlugin: waiting for connection
        INFO:  TcpForwardPlugin: connecting to 127.0.0.1:2500
        ERROR: TcpForwardPlugin: failure to connect; errno = 111
        INFO:  TcpForwardPlugin: connecting to 127.0.0.1:2500
        ERROR: TcpForwardPlugin: failure to connect; errno = 111
        ...

    3) Restart netcat in shell 2: netcat -l -p 2500

    => At the next connection attempt by the plug-in, the connection succeeds.
    => Once the connection is established, the TestDriver closes the socket and
    exits:

        ...
        ERROR: TcpForwardPlugin: failure to connect; errno = 111
        INFO:  TcpForwardPlugin: connecting to 127.0.0.1:2500
        INFO:  TcpForwardPlugin: connected to server
        INFO:  TcpForwardPlugin: connected
        INFO:  TcpForwardPlugin: Reset called
        INFO:  TcpForwardPlugin: shutting down TCP layer thread
        INFO:  TcpForwardPlugin: closing TCP connection
        1>



6.3. Test 1b: reconnection attempt delay
--------------------------------------------------------------------------------

Objective
    To test the reconnection delay.


Prerequisite
    As for Test 1a


Execution
    1) In shell 1, type: ./TestDriver 1 "127.0.0.1:2500, 5, 0"

    => The plug-in attempts to connect to the server every 5 seconds, instead of
    2 seconds as above.

    2) Stop the test by hitting ctrl-c.



6.4. Test 2a: ten times "Hello world!" in a row
--------------------------------------------------------------------------------

Objective
    To test message sending


Prerequisite
    As for Test 1a


Execution
    In shell 2, start netcat: netcat -l -p 2500 > dump

    In shell 1, start the test: ./TestDriver 2 "127.0.0.1:2500, 2, 0"

    => TestDriver connects to netcat, sends 10 messages "Hello World!", wait
    half a second, closes the socket and returns:

        INFO:  TcpForwardPlugin: Init called
        INFO:  TcpForwardPlugin: parameters: 127.0.0.1:2500, 2, 0
        INFO:  TcpForwardPlugin: server host: 127.0.0.1; port: 2500
        INFO:  TcpForwardPlugin: reconnect delay: 2 s
        INFO:  TcpForwardPlugin: unlimited msg queue size
        INFO:  TcpForwardPlugin: mission mode: 1
        INFO:  TcpForwardPlugin: TCP/IP layer initialisation
        INFO:  TcpForwardPlugin: starting TCP layer thread
        INFO:  TcpForwardPlugin: waiting for connection
        INFO:  TcpForwardPlugin: connecting to 127.0.0.1:2500
        INFO:  TcpForwardPlugin: connected to server
        INFO:  TcpForwardPlugin: connected
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: Reset called
        INFO:  TcpForwardPlugin: shutting down TCP layer thread
        INFO:  TcpForwardPlugin: closing TCP connection
        1>

    => The dump file contains the 10 hello world messages inside the Hadock
    envelope (format 1):

        f8 2e 35 53 02 01 00 00 00 00 00 0d 48 65 6c 6c
        6f 20 57 6f 72 6c 64 21 0a 74 80 f8 2e 35 53 02
        01 00 01 00 00 00 0d 48 65 6c 6c 6f 20 57 6f 72
        6c 64 21 0a 74 7f f8 2e 35 53 02 01 00 02 00 00
        00 0d 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 0a 74
        7e f8 2e 35 53 02 01 00 03 00 00 00 0d 48 65 6c
        6c 6f 20 57 6f 72 6c 64 21 0a 74 7d f8 2e 35 53
        02 01 00 04 00 00 00 0d 48 65 6c 6c 6f 20 57 6f
        72 6c 64 21 0a 74 7c f8 2e 35 53 02 01 00 05 00
        00 00 0d 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 0a
        74 7b f8 2e 35 53 02 01 00 06 00 00 00 0d 48 65
        6c 6c 6f 20 57 6f 72 6c 64 21 0a 74 7a f8 2e 35
        53 02 01 00 07 00 00 00 0d 48 65 6c 6c 6f 20 57
        6f 72 6c 64 21 0a 74 79 f8 2e 35 53 02 01 00 08
        00 00 00 0d 48 65 6c 6c 6f 20 57 6f 72 6c 64 21
        0a 74 78 f8 2e 35 53 02 01 00 09 00 00 00 0d 48
        65 6c 6c 6f 20 57 6f 72 6c 64 21 0a 74 77


Remark
    The logging reports that VMU packets are send. In fact the plug-in does not
    check the content of the packet it sends, but it assumes that they are VMU
    packets, which they are in operational conditions.



6.5. Test 2b: limited message queue
--------------------------------------------------------------------------------

Objective
    To test a bounded queue.


Prerequisite
    As for Test 1a


Execution
    In shell 2, start netcat: netcat -l -p 2500 > dump

    In shell 1, start the test: ./TestDriver 2 "127.0.0.1:2500, 2, 1"

    => TestDriver connects to netcat and attempts to send 10 messages "Hello
    World!", wait half a second, closes the socket and returns. Because the
    queue is limited to 1 elements, 9 out of the 10 messages are lost, since the
    messages are sent at once:

        1> ./TestDriver 2 "127.0.0.1:2500, 2, 1"
        INFO:  TcpForwardPlugin: Init called
        INFO:  TcpForwardPlugin: parameters: 127.0.0.1:2500, 2, 1
        INFO:  TcpForwardPlugin: server host: 127.0.0.1; port: 2500
        INFO:  TcpForwardPlugin: reconnect delay: 2 s
        INFO:  TcpForwardPlugin: msg queue size: 1
        INFO:  TcpForwardPlugin: mission mode: 1
        INFO:  TcpForwardPlugin: TCP/IP layer initialisation
        INFO:  TcpForwardPlugin: starting TCP layer thread
        INFO:  TcpForwardPlugin: waiting for connection
        INFO:  TcpForwardPlugin: connecting to 127.0.0.1:2500
        INFO:  TcpForwardPlugin: connected to server
        INFO:  TcpForwardPlugin: connected
        INFO:  TcpForwardPlugin: deleting oldest packet as queue is full
        INFO:  TcpForwardPlugin: deleting oldest packet as queue is full
        INFO:  TcpForwardPlugin: deleting oldest packet as queue is full
        INFO:  TcpForwardPlugin: deleting oldest packet as queue is full
        INFO:  TcpForwardPlugin: deleting oldest packet as queue is full
        INFO:  TcpForwardPlugin: deleting oldest packet as queue is full
        INFO:  TcpForwardPlugin: deleting oldest packet as queue is full
        INFO:  TcpForwardPlugin: deleting oldest packet as queue is full
        INFO:  TcpForwardPlugin: deleting oldest packet as queue is full
        INFO:  TcpForwardPlugin: sending a 13-byte VMU packet
        INFO:  TcpForwardPlugin: Reset called
        INFO:  TcpForwardPlugin: shutting down TCP layer thread
        INFO:  TcpForwardPlugin: closing TCP connection
        1>

    => The dump file contains only the last (10th) message. Its sequence number
    is "0009":

        f8 2e 35 53 02 01 00 09 00 00 00 0d 48 65 6c 6c
        6f 20 57 6f 72 6c 64 21 0a 74 77


Remark
    It is not strictly impossible that more than one message are sent due to
    favourable race conditions between the main thread (of the test driver) and
    the sending thread (of the plug-in). But it is extremely unlikely that the
    10 messages will be sent, as this would require a precise and accidental
    synchronisation between these two threads. In practice the test should be
    declared successful if at least a packet is discarded.



6.6. Test 3: sending actual VMU packets to Hadock
--------------------------------------------------------------------------------

Objectives
    To send actual VMU packet to an Hadock instance


Prerequisite
    1. The preparation step (ยง 6.1) was successful.
    2. Hadock is running on the server 'host' and listen to the port 'port'.
       (Alternatively, netcat can be used instead of Hadock)
    3. A shell is open in the plug-in folder
    4. A replay of VMU records is available in a data file


Execution

    Start the test, replacing 'host', 'port' and 'datafile' in the command below
    by their actual value:
        > ./TestDriver 3 "host:port, 2, 0" datafile

    => TestDriver reads the content of the data file and sends it to Hadok:

        INFO:  TcpForwardPlugin: Init called
        INFO:  TcpForwardPlugin: parameters: 127.0.0.1:2500, 2, 0
        INFO:  TcpForwardPlugin: server host: 127.0.0.1; port: 2500
        INFO:  TcpForwardPlugin: reconnect delay: 2 s
        INFO:  TcpForwardPlugin: unlimited msg queue size
        INFO:  TcpForwardPlugin: mission mode: 1
        INFO:  TcpForwardPlugin: TCP/IP layer initialisation
        INFO:  TcpForwardPlugin: starting TCP layer thread
        INFO:  TcpForwardPlugin: waiting for connection
        INFO:  TcpForwardPlugin: connecting to 127.0.0.1:2500
        INFO:  TcpForwardPlugin: connected to server
        INFO:  TcpForwardPlugin: connected
        INFO:  TcpForwardPlugin: sending a 115292-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 76892-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 14152-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 115292-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 76892-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 14152-byte VMU packet
        ...
        INFO:  TcpForwardPlugin: sending a 14152-byte VMU packet
        INFO:  TcpForwardPlugin: sending a 115292-byte VMU packet
        INFO:  TcpForwardPlugin: Reset called
        INFO:  TcpForwardPlugin: shutting down TCP layer thread
        INFO:  TcpForwardPlugin: closing TCP connection



Remark
    The test above was executed with the file rt_55_59.dat provided together
    with the plug-in for test purpose.



7. Implementation notes
================================================================================


7.1 Concurrent access: the message queue and the sending thread
--------------------------------------------------------------------------------

By looking at the implementation of IncomingVmuHandler::dataAvailable, which
calls HandleReceivedHrdlPacket (abbreviated as HRHP below), a comment in the
code warns that "StreamAPI (DASS- API) calls this from a new thread every time".
As a consequence, the calls to HRHP are concurrent.

To avoid that the TCP socket is accessed concurrently, a thread-safe queue is
used to forward VMU packets from the HRHP threads to a TcpForwardClient thread
dedicated to sending the packets to the network.

That thread periodically checks if a buffer is available in the queue. If it is
the case, it dequeues it and sends it to the TCP socket. Otherwise it sleeps for
5 ms before checking the queue again.



7.2. Concurrent access: static variables and procedures
--------------------------------------------------------------------------------

No information is available (at least to me) on the threading policy of DASS-
API. In particular, while it is reasonable to assume that HRHP won't be called
after a call to the static "Reset" function, I have no warranty that "Reset" is
called only if all Dass threads have returned from a previous call to HRHP. Were
this not be the case, the access of a plug-in instance member after a call to
Reset would likely crash the SE.

To avoid such a situation, the plug-in functionality is completely implemented
via static variables and functions.

================================================================================
